#' Simulate i.i.d. St. Petersburg random variables.
#'
#' Generates \code{n} independent draws from the St. Petersburg distribution,
#' where \eqn{P(X = 2^k) = 2^{-k}} for k = 1, 2, ... (infinite expectation).
#'
#' @param n Integer number of samples to draw.
#' @param seed Integer seed for reproducibility (optional).
#' @return Numeric vector of length \code{n} with simulated values.
#' @examples
#' set.seed(123)
#' r_stpetersburg(5)
#' # Example output: e.g. 2 2 4 2 2 (random)
r_stpetersburg <- function(n, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  # K = number of coin tosses until first tail (geometric with p=0.5), which has P(K=k) = 2^{-k}
  K <- stats::rgeom(n, prob = 0.5) + 1  # rgeom gives #failures (heads) before first success, so add 1
  X <- 2^K
  return(X)
}

#' Simulate multiple St. Petersburg game runs and summary statistics.
#'
#' Runs B independent experiments of n St. Petersburg gambles and computes 
#' summary statistics for each run, including sum, mean, scaled mean A_n, 
#' rare-event count N_n(c), maximum payoff, trimmed mean, and median-of-means.
#'
#' @param n Sample size (number of i.i.d. draws per run).
#' @param B Number of independent runs to simulate.
#' @param c Threshold factor for defining N_n(c) (default 10).
#' @param trim_frac Fraction for symmetric trimming in trimmed mean (default 0.1 for 10%).
#' @param mom_blocks Number of blocks for median-of-means estimator (default 10).
#' @param seed Random seed for reproducibility (optional).
#' @return A data frame with B rows and columns:
#'   \describe{
#'     \item{n}{Sample size used (same for all rows).}
#'     \item{S_n}{Sum of the n values in that run.}
#'     \item{mean}{Ordinary sample mean = S_n/n.}
#'     \item{A_n}{Scaled mean = S_n/(n * log2(n)).}
#'     \item{N_n}{Count of observations >= c * i * log2(i) within that run.}
#'     \item{M_n}{Maximum observation in that run.}
#'     \item{trimmed}{Trimmed (10\%) mean of that run's observations.}
#'     \item{median_of_means}{Median-of-means estimate from that run (using \code{mom_blocks} blocks).}
#'   }
#' @examples
#' sim <- simulate_stpetersburg_experiment(n = 1000, B = 100, seed = 42)
#' head(sim)
simulate_stpetersburg_experiment <- function(n, B, c = 10, 
                                             trim_frac = 0.1, 
                                             mom_blocks = 10,
                                             seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  
  # Preallocate vectors for results
  S_n_vec    <- numeric(B)
  mean_vec   <- numeric(B)
  A_n_vec    <- numeric(B)
  N_n_vec    <- numeric(B)
  M_n_vec    <- numeric(B)
  trimmed_vec<- numeric(B)
  mom_vec    <- numeric(B)
  
  for (b in 1:B) {
    # simulate n St. Petersburg values for this run
    X <- r_stpetersburg(n)
    S_n <- sum(X)
    S_n_vec[b]  <- S_n
    mean_vec[b] <- S_n / n
    A_n_vec[b]  <- S_n / (n * log2(n))
    # Count how many X[i] exceed threshold c * i * log2(i)
    # (We vectorize by computing threshold for each i and compare)
    i_seq <- seq_len(n)
    N_n_vec[b] <- sum(X >= c * i_seq * log2(i_seq))
    M_n_vec[b] <- max(X)
    # 10% symmetric trimmed mean
    trimmed_vec[b] <- mean(X, trim = trim_frac)
    # Median-of-means with k = mom_blocks
    mom_vec[b] <- median_of_means(X, k = mom_blocks)
  }
  
  return(data.frame(
    n = n,
    S_n = S_n_vec,
    mean = mean_vec,
    A_n = A_n_vec,
    N_n = N_n_vec,
    M_n = M_n_vec,
    trimmed = trimmed_vec,
    median_of_means = mom_vec
  ))
}


#' Median-of-means estimator for heavy-tailed data.
#'
#' Splits the data into \code{k} blocks, computes the mean of each block,
#' and returns the median of these block means. Provides a robust estimate 
#' of the true mean under heavy-tailed distributions.
#'
#' @param x Numeric vector of data (sample from a distribution).
#' @param k Number of blocks to split the data into.
#' @return The median of the means of the \code{k} blocks.
#' @examples
#' x <- r_stpetersburg(100, seed=1)
#' median_of_means(x, k = 5)
median_of_means <- function(x, k) {
  n <- length(x)
  if (k <= 1) {
    return(mean(x))  # if 1 block, just mean
  }
  # Assign each observation to one of k groups (approximately equal sizes)
  # We'll use the order they appear, which is random if x is random.
  group <- rep(1:k, length.out = n)
  block_means <- tapply(x, group, mean)
  return(stats::median(block_means))
}




